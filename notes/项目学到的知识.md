## c++11 thread线程类 

`<thread>` 头文件声明了 `std::thread` 线程类以及命名空间 `std::this_thread`

### 一、线程类的构造和赋值

#### 1、构造函数

|  | 函数 | 说明|
| :--: | :--:| :--: |
| 默认构造函数 | `thread() noexcept;` | 创建一个空的 `std::thread` 执行对象|
| 初始化构造函数 | `template <class Fn, class... Args>` <br> `explicit thread(Fn &&fn, Args&&... args);` | 创建一个 `std::thread` 对象 (可被 `joinable`)。调用 `fn` 函数，该函数的参数由 `args` 给出 |
| 拷贝构造函数 [deleted] | `thread(const thread &) = delete;` | `std::thread` 对象**不可拷贝构造** |
| Move 构造函数 | `thread(thread &&x) noexcept;` | 调用成功之后 `x` 不代表任何 `std::thread` 执行对象 |


#### 2、赋值操作

|  | 函数 | 说明|
| :--: | :--:| :--: |
| Move 赋值操作 | `thread& operator=(thread &&rhs) noexcept;` | 若当前对象不可 `joinable`，需要传递一个右值引用；若可被 `joinable`，则会调用 `terminate()` 报错|
| 拷贝赋值操作 | `thread& operator=(const thread&) = delete;` | `std::thread` **对象不可拷贝赋值**|


### 二、其他成员函数

- `get_id()`: 获取线程 ID，返回一个类型为 `std::thread::id` 的对象 

```c++
std::thread t(Work); // Work是线程的工作函数
std::thread::id t_id = t.get_id();
t.join();
```

- `joinable()`: 检查线程是否可被 join，即检查当前的线程对象是否表示了一个活动的执行线程 (`t.jionable()`)

由默认构造函数创建的线程是不能被 join 的

如果某个线程已经执行完任务，但是没有被 join 的话，该线程依然会被认为是一个活动的执行线程，因此也是可以被 join 的

- `join()`: 该函数会阻塞当前线程，直到子线程执行完成之后主线程才继续执行。此时主线程会释放子线程的资源

- `detach()`: 将子线程从主线程中分离出来，这样主线程就对子线程没有控制权了，子线程执行完成后会自己释放掉资源 （子线程的`joinable()` 变 false）

- `swap(thread& x, thread& y)`: 交换两个线程对象所代表的底层句柄 


### 三、`std::this_thread` 命名空间的辅助函数

- `get_id()`: 获取线程 ID (`std::thread::id t_id = std::this_thread::get_id();`)

- `yield()`: 当前线程放弃执行，操作系统调度另一线程继续执行 (`std::this_thread::yield();`)

- sleep_until: 线程休眠至某个指定的时刻(time point)，该线程才被重新唤醒

```c++
template<class Clock, class Duration>
void sleep_until( const std::chrono::time_point<Clock,Duration>& sleep_time );
```

- sleep_for: 线程休眠某个指定的时间片(time span)，该线程才被重新唤醒，不过由于线程调度等原因，实际休眠时间可能比 `sleep_duration` 所表示的时间片更长。

```c++
template< class Rep, class Period >
void sleep_for( const std::chrono::duration<Rep,Period>& sleep_duration );
```
 


## c++ 处理转移语义和完美转发
1. `std::move`：`std::move` 是一个函数模板，用于将一个对象标记为可移动的（右值引用）。它用于显式地表示对象的所有权将被转移，可以触发移动语义。使用 `std::move` 后，对象的值可以被移动（转移）到其他地方，而不是进行拷贝。通常用于移动构造函数、移动赋值运算符和需要显式标记对象为右值引用的场景
2. `std::forward`：`std::forward` 是一个条件性转发的工具，用于完美转发（forwarding）。它接受一个引用参数，并根据该参数的值的左值或右值特性，决定是否将该参数转发为左值引用或右值引用。`std::forward` 在函数模板中通常与类型推导结合使用，用于保留原始的值类别。主要用于完美转发参数，将参数以原始的值类别传递给下游函数

**总结**
- `std::move` 用于将对象标记为可移动的右值引用，触发移动语义，用于转移对象的所有权。
- `std::forward` 用于在函数模板中完美转发参数，保留原始的值类别，用于正确地将参数转发给下游函数。